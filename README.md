# cs-320-software-testing
# How can I ensure that my code, program, or software is functional and secure?
The way I ensure my code is functional and secure is by going over the requirements and breaking down the different parts into smaller components.
I address one requirement at a time and write unit tests as I am developing code. This helps me ensure I am addressing the requirements correctly and
I can catch more bugs when working with a more granular approach. When it comes to security, I first identify if there is any user input being used. I sanitize
any input from users as the first line of defense since this is where attacks such as SQL injections and malicious code execution can occur. After this, I run static
checks to keep any dependencies up to date in case there are any vulnerabilities. Finally, when it comes to APIs and networking, I prefer using certfificates and different
types of tokens to enforce proper authentication and authorization, and prevent spoofing or hijacking attacks.

# How do I interpret user needs and incorporate them into a program?
My approach is to use an Agile approach while keeping the user involved throughout the entire cycle. Using a granular approach, I can focus on making every aspect
to the specifications of the user, and the constant feedback helps me produce the desired feature or software. It is important to keep the user engaged throughout the
development process in case there are any changes to the requirements not to mention the continuous feedback helps me determine if I am on the right track or need to
make adjustments.

# How do I approach designing software?
My philosophy when it comes to designing software is to keep things as simple as possible. I looks at the business logic and the requirements for a feature or software,
and build basic components as a wireframe. As the development process goes along, I add complexity when inevitable. I think a common mistake to justify needless complexity
by anticipating needs in the distant future. With experience you learn to know when to look ahead and when to keep it simple. Preoptimization tends to do more damage than good
in many, if not most, cases. It is also important to note that adding complexity, especially in cases where it can be avoided, only adds to technical debt down the line.
